controller:
#  # 'name' is a name of an existing secret in the same namespace as jenkins,
#  # 'keyName' is the name of one of the keys inside the current secret.
#  # the 'name' and 'keyName' are concatenated with a '-' in between, so for example:
#  # an existing secret "secret-credentials" and a key inside it named "github-password" should be used in JCasC as ${secret-credentials-github-password}
#  # 'name' and 'keyName' must be lowercase RFC 1123 label must consist of lower case alphanumeric characters or '-',
#  # and must start and end with an alphanumeric character (e.g. 'my-name', or '123-abc')
#  # existingSecret existing secret "secret-credentials" and a key inside it named "github-username" should be used in JCasC as ${github-username}
#  # When using existingSecret no need to specify the keyName under additionalExistingSecrets.
#  existingSecret:
#
#  # -- List of additional existing secrets to mount
#  additionalExistingSecrets: [ ]
#  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets
#  # additionalExistingSecrets:
#  #  - name: secret-name-1
#  #    keyName: username
#  #  - name: secret-name-1
#  #    keyName: password
#
#  # -- List of additional secrets to create and mount
#  additionalSecrets: [ ]
#  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets
#  # additionalSecrets:
#  #  - name: nameOfSecret
#  #    value: secretText

## https://github.com/jenkinsci/helm-charts/issues/678
#  initScripts:
#    setup-known-hosts: |
#      new File("/var/jenkins_home/.ssh").mkdir()
#      File file = new File("/var/jenkins_home/.ssh/known_hosts")
#      file.write '${known_hosts}'

#  initConfigMap: jenkins-init-scripts (kustomize confimapgenerator references to a .groovy job)
#// init.groovy
#println "Configuring Jenkins during startup..."
#jenkins.model.Jenkins.instance.securityRealm = new hudson.security.LDAPSecurityRealm(...)
#jenkins.model.Jenkins.instance.save()
  probes:
    startupProbe:
      failureThreshold: 12 # -- Set the failure threshold for the startup probe
      periodSeconds: 10 # -- Set the time interval between two startup probes executions in seconds
      timeoutSeconds: 60 # -- Set the timeout for the startup probe in seconds
  sidecars:
    configAutoReload:
      enabled: false # require pod restart for config change. allows to view current temporary jcasc
#  containerEnv:
#    - name: CASC_JENKINS_CONFIG
#      value: "/var/jenkins_home/"
  image:
    repository: "jenkins/jenkins"
    tag: 2.440.3
  javaOpts: "-Xmx1536m -Xms512m -Dcasc.jenkins.config=/var/jenkins_home/casc_configs" # -Dcasc.jenkins.config=/var/jenkins_home/casc_configs prevent memory limit issues, define jcasc config path
  admin:
    username: "admin" # check
    password: "pass" # check
  serviceType: "ClusterIP"
  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "1"
      memory: "2Gi"
  service:
    port: 8080
  installPlugins:
    - kubernetes:4203.v1dd44f5b_1cf9
    - workflow-aggregator:596.v8c21c963d92d
    - git:5.2.1
    - configuration-as-code:1775.v810dc950b_514
    - ansible:307.va_1f3ef06575a_
    - docker-workflow:580.vc0c340686b_54
    - credentials:1337.v60b_d7b_c7b_c9f
#    - job-dsl:1.87
    - amazon-ecr:1.114.vfd22430621f5
  JCasC:
    enabled: true
    defaultConfig: true
    overwriteConfiguration: true # related to PVC. requires pod restart (or sidecars: configAutoReload: )
#    configScripts:
#      example-one: |
#        jenkins:
#          systemMessage: values.yaml custom message.
#      example-two: |
#        jenkins:
#          tool:
#            hello:

#nameSuffix: -prod
#You cannot use template calls ({{ .SomeValue }} in kustomize

  persistence:
    enabled: true #
    #existingClaim: jenkins
    # https://github.com/jenkinsci/helm-charts/issues/659
    # https://github.com/jenkinsci/helm-charts/issues/64
    storageClass: "gp3" # check # ebs-gp3
    size: "9Gi" # check (not applying)
    accessMode: "ReadWriteOnce" # ReadWriteMany for HA/efs

  ingress:
    enabled: true
    className: "alb"
    annotations:
      kubernetes.io/ingress.class: "alb"
      alb.ingress.kubernetes.io/scheme: "internet-facing" # "internet-facing"
      alb.ingress.kubernetes.io/target-type: "ip"
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 8080}]'
      alb.ingress.kubernetes.io/group.name: "argo-cd-cluster"
      alb.ingress.kubernetes.io/group.order: "2"
      alb.ingress.kubernetes.io/healthcheck-path: "/login"
      alb.ingress.kubernetes.io/healthcheck-port: "traffic-port"
      alb.ingress.kubernetes.io/success-codes: "200,302"
    paths:
      - backend:
          serviceName: jenkins
          servicePort: 8080
        path: /jenkins/* # obscure documentation https://stackoverflow.com/questions/66273304/jenkinsawsloadbalancercontroller-example
#  agentListenerServiceType: "NodePort" # "ClusterIP" # JNLP agent service
#    paths:
#      - path: "/jenkins/*"
#        pathType: ImplementationSpecific
#        backend:
#          service:
#            name: "jenkins"
#            port:
#              number: 8080
  nodeSelector:
    role: ci-cd

agent:
  nodeSelector:
    role: ci-cd

serviceAccount:
  create: true
  name: jenkins
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::350206045032:role/JenkinsRole"
